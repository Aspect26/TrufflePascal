package cz.cuni.mff.d3s.trupple.language.nodes.variables;

import com.oracle.truffle.api.dsl.NodeChild;
import com.oracle.truffle.api.dsl.NodeField;
import com.oracle.truffle.api.dsl.Specialization;
import cz.cuni.mff.d3s.trupple.language.nodes.ExpressionNode;
import cz.cuni.mff.d3s.trupple.language.runtime.customvalues.EnumValue;
import cz.cuni.mff.d3s.trupple.parser.identifierstable.types.TypeDescriptor;
import cz.cuni.mff.d3s.trupple.parser.identifierstable.types.primitive.LongDescriptor;

/**
 * This nodes evaluates the expression it gets and converts it to a valid index of an array keeping array offset in mind.
 *
 * This node uses specializations which means that it is not used directly but completed node is generated by Truffle.
 * {@link ReadIndexNodeGen}
 */
@NodeChild(type = ExpressionNode.class)
@NodeField(name = "offset", type = int.class)
public abstract class ReadIndexNode extends ExpressionNode {

    protected abstract int getOffset();

    /**
     * We need to return an int because arrays may be indexed only by ints in Java
     */
    @Specialization
    int getIntIndex(int index) {
        return index - getOffset();
    }

    @Specialization
    int getLongIndex(long index) {
        return (int) index - getOffset();
    }

    @Specialization
    int getCharIndex(char index) {
        return (int) index - getOffset();
    }

    @Specialization
    int getBooleanIndex(boolean index) {
        return ((index)? 1:0) - getOffset();
    }

    @Specialization
    int getEnumIndex(EnumValue index) {
        return (int) index.getOrdinalValue() - getOffset();
    }

    @Override
    public TypeDescriptor getType() {
        return LongDescriptor.getInstance();
    }

}
