COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit}.
stringLiteral = "'" { stringChar } "'".
integerLiteral = "0" | nonZeroDigit { digit }.
doubleLiteral = ("0" | nonZeroDigit { digit }) "e" ["-" | "+"] ("0" | nonZeroDigit { digit }) | ("0" | nonZeroDigit { digit }) "." ("0" | nonZeroDigit { digit }) ["e" ["-"|"+"] ("0" | nonZeroDigit { digit })].

PRAGMAS

COMMENTS FROM "(*" TO "*)"
COMMENTS FROM "{" TO "}"
IGNORE cr + lf + tab

PRODUCTIONS

Pascal
=
Program
Declarations
MainFunction
.


Program
=
    "program"
    identifier                                      (. factory.startPascal(t); .)
    ";"
.


Declarations
=
[ ConstantDefinitions ]
[ TypeDefinitions ]
[ VariableDeclarations ]
{ Subroutine }
.



TypeDefinitions
=
"type"
TypeDefinition ";"
{
    TypeDefinition ";"
}
.


TypeDefinition
=
identifier										(. Token identifier = t; .)
"="
Type<out TypeDescriptor typeDescriptor>         (. factory.registerNewType(identifier, typeDescriptor); .)
.



Type<out TypeDescriptor typeDescriptor>
=                                               (. typeDescriptor = null; .)
(
	identifier                                  (.  typeDescriptor = factory.getTypeDescriptor(t); .)
|
    EnumDefinition<out typeDescriptor>
|
	ArrayDefinition<. out List<OrdinalDescriptor> ordinalDimensions .>
	{
		IF(continuesArray())
		"of"
		ArrayDefinition<. out List<OrdinalDescriptor> additionalDimensions .>
												(. ordinalDimensions.addAll(additionalDimensions); .)
	}
	"of"
	identifier									(. typeDescriptor = factory.createArray(ordinalDimensions, t); .)
|
    "set" "of"
    Ordinal<out OrdinalDescriptor ordinal>      (. typeDescriptor = factory.createSetType(ordinal); .)
|
    FileType<out typeDescriptor>
)
.


ArrayDefinition<. out List<OrdinalDescriptor> ordinalDimensions .>
=
[ "packed" ]
"array"											(. ordinalDimensions = new ArrayList<>(); .)
"["												(. OrdinalDescriptor ordinalDescriptor = null; .)
Ordinal<out ordinalDescriptor>					(. ordinalDimensions.add(ordinalDescriptor); .)
{
	","
	Ordinal<out ordinalDescriptor>				(. ordinalDimensions.add(ordinalDescriptor); .)
}
"]"
.


EnumDefinition<out TypeDescriptor typeDescriptor>
=                                               (. List<String> enumIdentifiers = new ArrayList<>(); .)
"("
    identifier                                  (. enumIdentifiers.add(factory.getIdentifierFromToken(t)); .)
    {
        ","
        identifier                              (. enumIdentifiers.add(factory.getIdentifierFromToken(t)); .)
    }
")"                                             (. typeDescriptor = factory.registerEnum(enumIdentifiers); .)
.


FileType<out TypeDescriptor fileDescriptor>
=
"file" "of"
Type<out TypeDescriptor contentType>            (. fileDescriptor = factory.createFileType(contentType); .)
.


Ordinal<out OrdinalDescriptor ordinal>
=												(. ordinal = null; .)
(
    IF(isSubrange())
	SubrangeType<out ordinal>
|
	Type<out TypeDescriptor typeDescriptor>     (. ordinal = factory.castTypeToOrdinalType(typeDescriptor); .)
)
.


SubrangeType<out OrdinalDescriptor ordinal>
=
Constant<out ConstantDescriptor lowerBound>
".."
Constant<out ConstantDescriptor upperBound>     (. ordinal = factory.createSimpleOrdinalDescriptor(lowerBound, upperBound); .)
.


ConstantDefinitions
=
"const"
ConstantDefinition ";"
{
    ConstantDefinition ";"
}
.


ConstantDefinition
=
identifier										(. Token identifier = t; .)
"="
Constant<out ConstantDescriptor constant>       (. factory.registerConstant(identifier, constant); .)
.


Constant<out ConstantDescriptor constant>
=
                                                (. constant = null; String sign = ""; .)
[
    "+" | "-"                                   (. sign = t.val; .)
]
(
	UnsignedIntegerLiteral<out long value>      (. constant = factory.createLongConstant(sign, value); .)
|
    UnsignedDoubleLiteral<out double value>     (. constant = factory.createDoubleConstant(sign, value); .)
|
	StringLiteral<out String value> 			(. constant = factory.createCharOrStringConstant(sign, value); .)
|
	IdentifierConstant<out Token identifier>    (. constant = factory.createConstantFromIdentifier(sign, identifier); .)
)
.


UnsignedIntegerLiteral<out long value>
=
integerLiteral                                  (. value = factory.getLongFromToken(t); .)
.


UnsignedDoubleLiteral<out double value>
=
doubleLiteral                                   (. value = factory.getDoubleFromToken(t); .)
.


IdentifierConstant<out Token identifierToken>
=
identifier                                      (. identifierToken = t; .)
.


VariableDeclarations
=
"var"
VariableLineDeclaration ";"
{
    VariableLineDeclaration ";"
}
.


VariableLineDeclaration
=                                               (. List<String> identifiers = new ArrayList<>(); .)
identifier                                      (. identifiers.add(factory.getIdentifierFromToken(t)); .)
{
    ","
    identifier                                  (. identifiers.add(factory.getIdentifierFromToken(t)); .)
}
":"
Type<out TypeDescriptor typeDescriptor>         (. factory.registerVariables(identifiers, typeDescriptor); .)
.



Subroutine
=
(
    Procedure ";"
|
    Function ";"
)
.


Procedure
=
"procedure"
identifier                                      (. Token identifierToken = t; .)
                                                (. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ]
";"
(
    "forward"                                   (. factory.forwardProcedure(identifierToken, formalParameters); .)
|
                                                (. factory.startProcedureImplementation(identifierToken, formalParameters); .)
    Declarations
    Block<out StatementNode bodyNode>           (. factory.finishProcedureImplementation(bodyNode); .)
)
.


Function
=
"function"
identifier                                      (. Token identifierToken = t; .)
                                                (. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ]
":"
identifier                                      (. Token returnTypeToken = t; .)
";"
(
    "forward"                                   (. factory.forwardFunction(identifierToken, formalParameters, returnTypeToken); .)
|
                                                (. factory.startFunctionImplementation(identifierToken, formalParameters, returnTypeToken); .)
    Declarations
    Block<out StatementNode bodyNode>           (. factory.finishFunctionImplementation(bodyNode); .)
)
.


FormalParameterList<. out List<FormalParameter> formalParameters .>
=
"("												(. formalParameters = new ArrayList<>(); .)
												(. List<FormalParameter> newParameters = new ArrayList<>(); .)
FormalParameter<out newParameters>				(. factory.appendFormalParameter(newParameters, formalParameters); .)
{ 
	";" 
	FormalParameter<out newParameters> 			(. factory.appendFormalParameter(newParameters, formalParameters); .)
}
")"
.



FormalParameter<. out List<FormalParameter> formalParameter .>
=												(. List<String> identifiers = new ArrayList<>(); .)
identifier										(. identifiers.add(factory.getIdentifierFromToken(t)); .)
{
	","
	identifier									(. identifiers.add(factory.getIdentifierFromToken(t)); .)
}
":"
identifier										(. formalParameter = factory.createFormalParametersList(identifiers, factory.getTypeNameFromToken(t), false); .)
.



MainFunction 
=
Block<out StatementNode blockNode>              (. mainNode = factory.finishMainFunction(blockNode); .)
"."
.


Block<out StatementNode blockNode>
=                                               
    "begin"                                     (. List<StatementNode> bodyNodes = new ArrayList<>(); .)
    [ 
        StatementSequence<bodyNodes>
    ]
    "end"                                       (. blockNode = factory.createBlockNode(bodyNodes); .)
.


StatementSequence<. List<StatementNode> body .>
=
Statement<out StatementNode statement>          (. body.add(statement); .)
{
    ";"
    Statement<out statement>                    (. body.add(statement); .)
}                                       
.


Statement<out StatementNode statement>
=                                               (. statement = null; .)
(
                                                (. statement = factory.createNopStatement(); .)
|
    IfStatement<out statement>
|
	ForLoop<out statement>
|
	WhileLoop<out statement>
|
	RepeatLoop<out statement>
|
	CaseStatement<out statement>
|
    Block<out statement>
|
    IdentifierBeginningStatement<out statement>
)
.



IdentifierBeginningStatement<out StatementNode statement>
=                                               (. statement = null; .)
identifier                                      (. Token identifierToken = t; .)
(
                                                (. statement = factory.createSubroutineCall(identifierToken, new ArrayList<ExpressionNode>()); .)
|
    SubroutineCall<out statement, identifierToken>
|
    AssignmentAfterIdentifierPart<out statement, identifierToken>
)
.



AssignmentAfterIdentifierPart<out StatementNode statement, Token identifierToken>
=
                                                (. List<ExpressionNode> indexNodes = null; .)
    [
        ArrayIndex<out indexNodes>
    ]
    ":="
    Expression<out ExpressionNode value>        (. statement = (indexNodes == null)? factory.createAssignment(identifierToken, value) : factory.createArrayIndexAssignment(identifierToken, indexNodes, value); .)
.



CaseStatement<out StatementNode statement>
=
"case"
Expression<out ExpressionNode caseExpression>
"of"
CaseList<out CaseStatementData caseData>        (. caseData.caseExpression = caseExpression; .)
"end"											(. statement = factory.createCaseStatement(caseData); .)
.



CaseList<out CaseStatementData data>
=                                               (. data = new CaseStatementData(); .)
Expression<out ExpressionNode caseConstant>     (. data.indexNodes.add(caseConstant); .)
":"
Statement<out StatementNode caseStatement>		(. data.statementNodes.add(caseStatement); .)
{
	IF(!caseEnds())
	";"
	Expression<out caseConstant>                (. data.indexNodes.add(caseConstant); .)
	":"
	Statement<out caseStatement>				(. data.statementNodes.add(caseStatement); .)
}
[ ";" ]
[
	"else"
	Statement<out data.elseNode>
]
[ ";" ]
.



ForLoop<out StatementNode statement>
=                                               (. factory.startLoop(); .)
"for"											(. boolean ascending = true; .)
identifier										(. Token variableToken = t; .)
":="
Expression<out ExpressionNode startValue>
(
	"to"										(. ascending = true; .)
	|
	"downto"									(. ascending = false; .)
)
Expression<out ExpressionNode finalValue>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createForLoop(ascending, variableToken, startValue, finalValue, loopBody); .)
                                                (. factory.finishLoop(); .)
.


RepeatLoop<out StatementNode statement>
=												(. factory.startLoop(); .)
"repeat"										(. List<StatementNode> bodyNodes = new ArrayList<>(); .)
StatementSequence<bodyNodes>
"until"
Expression<out ExpressionNode condition>		(. statement = factory.createRepeatLoop(condition, factory.createBlockNode(bodyNodes)); .)
                                                (. factory.finishLoop(); .)
.


WhileLoop<out StatementNode statement>
=												(. factory.startLoop(); .)
"while"
Expression<out ExpressionNode condition>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createWhileLoop(condition, loopBody); .)
												(. factory.finishLoop(); .)
.


IfStatement<out StatementNode statement>
=
"if"
    Expression<out ExpressionNode condition>

"then"
    Statement<out StatementNode thenStatement>
                                                (. StatementNode elseStatement = null; .)
[
"else"
    Statement<out elseStatement>
]                                               (. statement = factory.createIfStatement(condition, thenStatement, elseStatement); .)
.


Expression<out ExpressionNode expression>
=
LogicTerm<out expression>
{
    "or"                                        (. Token op = t; .)
    LogicTerm<out ExpressionNode right>         (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


LogicTerm<out ExpressionNode expression>
=
SignedLogicFactor<out expression>
{
    "and"                                       (. Token op = t; .)
    SignedLogicFactor<out ExpressionNode right> (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


SignedLogicFactor<out ExpressionNode expression>
=												(. expression = null; .)
(
	"not"										(. Token op = t; .)
	SignedLogicFactor<out ExpressionNode right>	(. expression = factory.createUnaryExpression(op, right); .)
|
	LogicFactor<out expression>
)
.



LogicFactor<out ExpressionNode expression>
=
Arithmetic<out expression>
[
    (">" | ">=" | "<" | "<=" | "=" | "<>" | "in")
                                                (. Token op = t; .)
    Arithmetic<out ExpressionNode right>        (. expression = factory.createBinaryExpression(op, expression, right); .)
]
.


Arithmetic<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
SignedFactor<out expression>
{
    ( "*" | "/" | "div" | "mod")                (. Token op = t; .)
    SignedFactor<out ExpressionNode right>      (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


SignedFactor<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    ( "+" | "-" )                               (. Token unOp = t; .)
    SignedFactor<out expression>                (.  expression = factory.createUnaryExpression(unOp, expression); .)
|
    Factor<out expression>
)
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	identifier
    (
	    MemberExpression<out expression, t>
    |
                                                (. expression = factory.createExpressionFromSingleIdentifier(t); .)
    )
|
    "("
    Expression<out expression>
    ")"
|
                                                (. String value = ""; .)
	StringLiteral<out value>		            (. expression = factory.createCharOrStringLiteralNode(value); .)
|
	doubleLiteral								(. expression = factory.createFloatLiteralNode(t); .)
|
    integerLiteral                              (. expression = factory.createNumericLiteralNode(t); .)
|
												(. boolean val; .)
    LogicLiteral<out val>						(. expression = factory.createLogicLiteralNode(val); .)
|
    SetConstructor<out expression>
)
.


StringLiteral<out String value>
=
stringLiteral                                   (. value = factory.createStringFromToken(t); .)
.



LogicLiteral<out boolean result>
=												(. result = false; .)
(
	"true"										(. result = true; .)
|
	"false"										(. result = false; .)
)
.


SetConstructor<out ExpressionNode expression>
=                                               (. expression = null; .)
"["
    (
                                                (. expression = factory.createSetConstructorNode(new ArrayList<>()); .)
    |
                                                (. List<ExpressionNode> valueNodes = new ArrayList<ExpressionNode>(); .)
        Expression<out ExpressionNode valueNode>(. valueNodes.add(valueNode); .)
        {
            ","
            Expression<out valueNode>           (. valueNodes.add(valueNode); .)
        }
                                                (. expression = factory.createSetConstructorNode(valueNodes); .)
    )
"]"
.


MemberExpression<out ExpressionNode expression, Token identifierName>
=							                    (. expression = null; .)
(
	SubroutineCall<out expression, identifierName>
|
	ArrayIndex<. out List<ExpressionNode> indexNodes .>  (. expression = factory.createReadArrayValue(identifierName, indexNodes); .)
)
.


SubroutineCall<out ExpressionNode expression, Token identifierToken>
=
"("
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
    [
        ActualParameters<out parameters, identifierToken>
    ]
")"                                             (. expression = factory.createSubroutineCall(identifierToken, parameters); .)
.


ActualParameters<. out List<ExpressionNode> parameters, Token subroutineToken .>
=
                                                (. parameters = new ArrayList<>(); .)
                                                (. int currentParameter = 0; .)
ActualParameter<out ExpressionNode parameter, currentParameter, subroutineToken>
                                                (. parameters.add(parameter); .)
{
    ","
    ActualParameter<out parameter, ++currentParameter, subroutineToken>
                                                (. parameters.add(parameter); .)
}
.


ActualParameter<out ExpressionNode parameter, int currentParameterIndex, Token subroutineToken>
=
                                                (. parameter = null; .)
(
    IF(factory.shouldBeReference(subroutineToken, currentParameterIndex))
    identifier                                  (. parameter = factory.createReferenceNode(t); .)
    // read is implemented with references
|
    Expression<out parameter>
)
.



ArrayIndex<. out List<ExpressionNode> indexNodes .>
=
												(. indexNodes = new ArrayList<>(); .)
												(. ExpressionNode indexingNode = null; .)
"["
	Expression<out indexingNode>	            (. indexNodes.add(indexingNode); .)
	{
		","
		Expression<out indexingNode>	        (. indexNodes.add(indexingNode); .)
	}
"]"
.


END Pascal.
