COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit}.
stringLiteral = "'" { stringChar } "'".
integerLiteral = "0" | nonZeroDigit { digit }.
doubleLiteral = ("0" | nonZeroDigit { digit }) "e" ["-" | "+"] ("0" | nonZeroDigit { digit }) | ("0" | nonZeroDigit { digit }) "." ("0" | nonZeroDigit { digit }) ["e" ["-"|"+"] ("0" | nonZeroDigit { digit })].

PRAGMAS

COMMENTS FROM "(*" TO "*)"
COMMENTS FROM "{" TO "}"
IGNORE cr + lf + tab

PRODUCTIONS

Pascal = 
(                                               (. factory.startPascal(); .)
	[ ImportsSection ]
	{ Declaration }
	MainFunction
|
	Unit
)
.


ImportsSection
=
"uses"
identifier										(. factory.importUnit(t); .)
{
	","
	identifier									(. factory.importUnit(t); .)
}
";"
.



Declaration
=
( 
	VariableDefinitions 
|
	ConstantDefinition
|
	TypeDefinition
|
	Subroutine
)
.



TypeDefinition
=
"type"
identifier										(. Token identifier = t; .)
"="
(
	Enum<identifier>
)
";"
.



Enum<Token identifier>
=
"("												(. List<String> identifiers = new ArrayList<String>(); .)
	identifier									(. identifiers.add(t.val.toLowerCase()); .)
	{ 
		","
		identifier 								(. identifiers.add(t.val.toLowerCase()); .)
	}
")"												(. factory.registerEnumType(identifier.val.toLowerCase(), identifiers); .)
.



ConstantDefinition
=
"const"
identifier										(. Token identifier = t; .)
"="
(
	NumericConstant<out NumericConstant value>	(. factory.createNumericConstant(identifier, value); .)	
|
	StringConstant<out String value> 			(. factory.createStringOrCharConstant(identifier, value); .)	
|
	LogicConstant<out boolean value>			(. factory.createBooleanConstant(identifier, value); .)
|
	identifier									(. factory.createObjectConstant(identifier, t); .)
)
";"
.


LogicConstant<out boolean value>
=
LogicTermConstant<out value>
{
	"or"
	LogicTermConstant<out boolean rvalue>		(. value = value || rvalue; .)
}
.


LogicTermConstant<out boolean value>
=
LogicFactorConstant<out value>
{
	"and"
	LogicFactorConstant<out boolean rvalue>		(. value = value && rvalue; .)
}
.


LogicFactorConstant<out boolean value>
=												(. value = false; .)
(
	"not"
	LogicFactorConstant<out boolean negatedValue>		
												(. value = !negatedValue; .)
|
	LogicSingleConstant<out value>
)
.


LogicSingleConstant<out boolean value>
=												(. value = false; .)
(
	LogicLiteral<out value>
|
	identifier									(. value = factory.getBooleanConstant(t); .)
)
.




StringConstant<out String value>
=
StringValue<out value>
{
	"+"
	StringValue<out String rvalue>				(. value = value.concat(rvalue); .)
}
.


StringValue<out String value>
=												(. value = ""; .)
(
	stringLiteral								(. value = factory.createStringFromLiteral(t); .)
|
	identifier									(. value = factory.getStringConstant(t); .)
)
.



NumericConstant<out NumericConstant value>
=												(. value = null; .)
(
	( "+" | "-" )								(. Token signToken = t; .)
	NumericConstant<out NumericConstant signedValue>		
												(. value = factory.createUnsignedConstant(signedValue, signToken); .)
|
	UnsignedNumericArithmeticConstant<out value>
)
.


UnsignedNumericArithmeticConstant<out NumericConstant value>
=
NumericTermConstant<out value>
{
	( "+" | "-" )								(. Token opToken = t; .)
	NumericTermConstant<out NumericConstant rvalue>	
												(. value = factory.createNumericConstantFromBinary(value, rvalue, opToken); .)
}
.


NumericTermConstant<out NumericConstant value>
=
NumericFactorConstant<out value>
{
	( "*" | "/" | "div" | "mod" )				(. Token opToken = t; .)
	NumericFactorConstant<out NumericConstant rvalue>	
												(. value = factory.createNumericConstantFromBinary(value, rvalue, opToken); .)
}
.


NumericFactorConstant<out NumericConstant value>
=												(. value = null; .)
(
	integerLiteral								(. value = new NumericConstant(Long.parseLong(t.val), false); .)
|
	doubleLiteral								(. value = new NumericConstant(Double.parseDouble(t.val), true); .)
|
	identifier									(. value = factory.getNumericConstant(t); .)
)
.



VariableDefinitions
=
"var"
VariableLineDefinition ";"
{
    VariableLineDefinition ";"
}
.


VariableLineDefinition
=                                               (. List<String> identifiers = new ArrayList<>(); .)
identifier                                      (. identifiers.add(t.val.toLowerCase()); .)
{
    ","
    identifier                                  (. identifiers.add(t.val.toLowerCase()); .)
}
":"
(
	identifier                                  (. factory.registerVariables(identifiers, t); .)
|
	ArrayDefinition<. out List<OrdinalDescriptor> ordinalDimensions .>
	{
		IF(continuesArray())
		"of"
		ArrayDefinition<. out List<OrdinalDescriptor> additionalDimensions .>
												(. ordinalDimensions.addAll(additionalDimensions); .)
	}
	"of"
	identifier									(. factory.registerArrayVariable(identifiers, ordinalDimensions, t); .)
)
.


ArrayDefinition<. out List<OrdinalDescriptor> ordinalDimensions .>
=
[ "packed" ]
"array"											(. ordinalDimensions = new ArrayList<>(); .)
"["												(. OrdinalDescriptor ordinalDescriptor = null; .)
Ordinal<out ordinalDescriptor>					(. ordinalDimensions.add(ordinalDescriptor); .)
{
	","
	Ordinal<out ordinalDescriptor>				(. ordinalDimensions.add(ordinalDescriptor); .)
}
"]"
.



Ordinal<out OrdinalDescriptor ordinal>
=												(. ordinal = null; .)
(												(. int lowerBound, upperBound; .)
	SignedIntegerLiteral<out lowerBound>
	".."
	SignedIntegerLiteral<out upperBound>
												(. ordinal = factory.createSimpleOrdinalDescriptor(lowerBound, upperBound); .)
|
	identifier									(. Token identifier = t; .)
												(. ordinal = factory.createSimpleOrdinalDescriptorFromTypename(identifier); .)
)
.


SignedIntegerLiteral<out int value>
=                                               (. value = 0; .)
(
    "+"
    SignedIntegerLiteral<out value>
|
    "-"
    SignedIntegerLiteral<out value>             (. value = -value; .)
|
    integerLiteral                              (. value = Integer.parseInt(t.val); .)
)
.


Subroutine
=
(
    Procedure
|
    Function
)
.


Procedure
=
"procedure"
identifier                                      (. Token identifierToken = t; .)
                                                (. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ]
";"                                             (. factory.startProcedure(identifierToken, formalParameters); .)
(
    "forward;"                                  (. factory.finishProcedure(); .)
|
    { Declaration }
    Block<out StatementNode bodyNode>           (. factory.finishProcedure(bodyNode); .)
)
.


Function
=
"function"
identifier                                      (. Token identifierToken = t; .)
                                                (. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ]
":"
identifier                                      (. Token returnTypeToken = t; .)
";"                                             (. factory.startFunction(identifierToken, formalParameters, returnTypeToken); .)
(
    "forward;"                                  (. factory.finishFunction(); .)
|
    { Declaration }
    Block<out StatementNode bodyNode>           (. factory.finishFunction(bodyNode); .)
)
.


FormalParameterList<. out List<FormalParameter> formalParameters .>
=
"("												(. formalParameters = new ArrayList<>(); .)
												(. List<FormalParameter> newParameters = new ArrayList<>(); .)
FormalParameter<out newParameters>				(. factory.appendFormalParameter(newParameters, formalParameters); .)
{ 
	";" 
	FormalParameter<out newParameters> 			(. factory.appendFormalParameter(newParameters, newParameters); .)
}
")"
.



FormalParameter<. out List<FormalParameter> formalParameter .>
=												(. List<String> identifiers = new ArrayList<>(); .)
												(. boolean isOutput = false; .)
[ 
	"var"										(. isOutput = true; .)
]
identifier										(. identifiers.add(t.val.toLowerCase()); .)
{
	","
	identifier									(. identifiers.add(t.val.toLowerCase()); .)
}
":"
identifier										(. formalParameter = factory.createFormalParametersList(identifiers, t.val.toLowerCase(), isOutput); .)
.



MainFunction 
=
Block<out StatementNode blockNode>              (. mainNode = factory.finishMainFunction(blockNode); .)
"."
.


Block<out StatementNode blockNode>
=                                               
    "begin"                                     (. List<StatementNode> bodyNodes = new ArrayList<>(); .)
    [ 
        StatementSequence<bodyNodes>
    ]
    "end"                                       (. blockNode = factory.createBlockNode(bodyNodes); .)
.


StatementSequence<. List<StatementNode> body .>
=
Statement<out StatementNode statement>          (. body.add(statement); .)
{
    ";"
    Statement<out statement>                    (. body.add(statement); .)
}                                       
.


Statement<out StatementNode statement>
=                                               (. statement = null; .)
(
                                                (. statement = factory.createNopStatement(); .)
|
    Expression<out statement> 
|
    IfStatement<out statement>
|
	ForLoop<out statement>
|
	WhileLoop<out statement>
|
	RepeatLoop<out statement> 
|
	CaseStatement<out statement>
|
	"break"										(. statement = factory.createBreak(); .)
|
    Block<out statement>
|
	ReadStatement<out statement>	
|
	"randomize"									(. statement = factory.createRandomizeNode(); .)		
)
.




ReadStatement<out StatementNode statement>
=
"readln"										(. statement = null; .)
(
												(. statement = factory.createReadLine(); .)
|
	"("											(. List<String> identifiers = new ArrayList<>(); .)
	(
		")"										(. statement = factory.createReadLine(); .)
	|
		identifier								(. identifiers.add(t.val.toLowerCase()); .)
		{
			","
			identifier							(. identifiers.add(t.val.toLowerCase()); .)
		}
	")"											(. statement = factory.createReadLine(identifiers); .)
	)
)
.



CaseStatement<out StatementNode statement>
=
"case"
Expression<out ExpressionNode caseIndex>
"of"											(. factory.startCaseList();	.)
CaseList 										
"end"											(. statement = factory.finishCaseStatement(caseIndex); .)
.



CaseList
=
Expression<out ExpressionNode caseConstant>
":"
Statement<out StatementNode caseStatement>		(. factory.addCaseOption(caseConstant, caseStatement); .)
{
	IF(!caseEnds())
	";"
	Expression<out caseConstant>
	":"
	Statement<out caseStatement>				(. factory.addCaseOption(caseConstant, caseStatement); .)
}
[ ";" ]
												(. StatementNode elseStatement = null; .)
[
	"else"
	Statement<out elseStatement>				(. factory.setCaseElse(elseStatement); .)
]
[ ";" ]
.



ForLoop<out StatementNode statement>
=                                               (. factory.startLoop(); .)
"for"											(. boolean ascending = true; .)
identifier										(. Token variableToken = t; .)
":="
Expression<out ExpressionNode startValue>	
(
	"to"										(. ascending = true; .)
	|
	"downto"									(. ascending = false; .)
)
Expression<out ExpressionNode finalValue>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createForLoop(ascending, variableToken, startValue, finalValue, loopBody); .)
                                                (. factory.finishLoop(); .)
.	


RepeatLoop<out StatementNode statement>
=												(. factory.startLoop(); .)
"repeat"										(. List<StatementNode> bodyNodes = new ArrayList<>(); .)
StatementSequence<bodyNodes>					
"until"
Expression<out ExpressionNode condition>		(. statement = factory.createRepeatLoop(condition, factory.createBlockNode(bodyNodes)); .)
                                                (. factory.finishLoop(); .)
.


WhileLoop<out StatementNode statement>
=												(. factory.startLoop(); .)
"while"
Expression<out ExpressionNode condition>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createWhileLoop(condition, loopBody); .)
												(. factory.finishLoop(); .)
.


IfStatement<out StatementNode statement>
=
"if"                                            
    Expression<out ExpressionNode condition>

"then"                                          
    Statement<out StatementNode thenStatement>
                                                (. StatementNode elseStatement = null; .)
[
"else"                                          
    Statement<out elseStatement>
]                                               (. statement = factory.createIfStatement(condition, thenStatement, elseStatement); .)
.


Expression<out ExpressionNode expression>
=
LogicTerm<out expression>
{
    "or"                                        (. Token op = t; .)
    LogicTerm<out ExpressionNode right>         (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


LogicTerm<out ExpressionNode expression>
=
SignedLogicFactor<out expression>
{
    "and"                                       (. Token op = t; .)
    SignedLogicFactor<out ExpressionNode right> (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


SignedLogicFactor<out ExpressionNode expression>
=												(. expression = null; .)
(
	"not"										(. Token op = t; .)
	SignedLogicFactor<out ExpressionNode right>	(. expression = factory.createUnaryExpression(op, right); .)
|
	LogicFactor<out expression>
)
.



LogicFactor<out ExpressionNode expression>
=
Arithmetic<out expression>
[
    (">" | ">=" | "<" | "<=" | "=" | "<>")      (. Token op = t; .)
    Arithmetic<out ExpressionNode right>        (. expression = factory.createBinaryExpression(op, expression, right); .)
]
.


Arithmetic<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
SignedFactor<out expression>
{
    ( "*" | "/" | "div" | "mod")                (. Token op = t; .)
    SignedFactor<out ExpressionNode right>      (. expression = factory.createBinaryExpression(op, expression, right); .)
}
.


SignedFactor<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    ( "+" | "-" )                               (. Token unOp = t; .)
    SignedFactor<out expression>                (.  expression = factory.createUnaryExpression(unOp, expression); .)
|
    Factor<out expression>                                        
)
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	Random<out expression>
|
	identifier
    (
	    MemberExpression<out expression, t>
    |
                                                (. expression = factory.readSingleIdentifier(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Undefined identifier " + t.val + "."); .)
    )
|
    "("
    Expression<out expression>                  
    ")"
|
                                                (. String value = ""; .)
	StringLiteral<out value>		            (. expression = factory.createCharOrStringLiteral(value); .)
|
	doubleLiteral								(. expression = factory.createFloatLiteral(t); .)
|
    integerLiteral                              (. expression = factory.createNumericLiteral(t); .)
|
												(. boolean val; .)
    LogicLiteral<out val>						(. expression = factory.createLogicLiteral(val); .)
)
.


StringLiteral<out String value>
=
stringLiteral                                   (. value = factory.createStringFromToken(t); .)
{
    stringLiteral                               (. value += "'" + factory.createStringFromToken(t); .)
}
.



LogicLiteral<out boolean result>
=												(. result = false; .)
(
	"true"										(. result = true; .)
|
	"false"										(. result = false; .)
)
.



Random<out ExpressionNode expression>
=
"random"										(. expression = null; .)
(
												(. expression = factory.createRandomNode(); .)
|
	"("
	(
		")"										(. expression = factory.createRandomNode(); .)
	|
		integerLiteral							(. expression = factory.createRandomNode(t); .)
		")"
	)
)
.




MemberExpression<out ExpressionNode expression, Token identifierName>
=							                    (. expression = null; .)
(                                               
	"("						                    (. ExpressionNode functionNode = factory.createFunctionNode(identifierName); .)
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
                                                (. ExpressionNode parameter; .)
		[
			Expression<out parameter>           (. parameters.add(parameter); .)
			{
				","
				Expression<out parameter>       (. parameters.add(parameter); .)
			}
		]
	")"                                         (. expression = factory.createCall(functionNode, parameters); .)
|
    ":="
    Expression<out ExpressionNode value>        (. if(identifierName == null) { .) 
                                                (.      SemErr("Invalid assignment target!"); .)
                                                (. } else { .)
                                                (.      expression = factory.createAssignment(identifierName, value); .)
                                                (.      if(expression == null) .)
                                                (.          SemErr("Undefined variable " + identifierName.val.toLowerCase() + "."); .)
                                                (. } .)
|
	ArrayAccessing<out expression, identifierName>
)
.



ArrayAccessing<out ExpressionNode expression, Token identifierName>
=												(. expression = null; .)
												(. List<ExpressionNode> indexingNodes = new ArrayList<>(); .)
												(. ExpressionNode indexingNode = null; .)
"["
	Expression<out indexingNode>	            (. indexingNodes.add(indexingNode); .)
	{
		","
		Expression<out indexingNode>	        (. indexingNodes.add(indexingNode); .)
	}
"]"
(
												(. expression = factory.createReadArrayValue(identifierName, indexingNodes); .)
|
	":="
	Expression<out ExpressionNode value>		(. expression = factory.createArrayIndexAssignment( .)
												(.		identifierName, indexingNodes, value); .)
)
.



Unit
=
"unit"
identifier										(. factory.startUnit(t); .)
";"
"interface"
InterfaceSection
"implementation"								(. factory.leaveUnitInterfaceSection(); .)
ImplementationSection
"end"											(. factory.endUnit(); .)
"."
.


InterfaceSection
=
{
	(
		ProcedureHeading
	|
		FunctionHeading
	|
		VariableDefinitions
	|
		TypeDefinition
	)
}
.



ProcedureHeading
=
"procedure"
identifier										(. Token name = t; .)
												(. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ] 		
												(. factory.addProcedureInterface(name, formalParameters); .)
";"
.



FunctionHeading
=
"function"
identifier										(. Token name = t; .)
												(. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ] 
":"
identifier										(. String returnValue = t.val; .)
												(. factory.addFunctionInterface(name, formalParameters, returnValue); .)
";"
.



ImplementationSection
=
{
	(
		Subroutine
	|
		VariableDefinitions
	|
		TypeDefinition
	)
}
.

END Pascal.
