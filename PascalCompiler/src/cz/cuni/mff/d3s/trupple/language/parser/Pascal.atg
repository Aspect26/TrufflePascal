COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit}.
stringLiteral = "'" { stringChar } "'".
numericLiteral = "0" | nonZeroDigit { digit }.
floatLiteral = ("0" | nonZeroDigit { digit }) "e" ["-" | "+"] ("0" | nonZeroDigit { digit }) | ("0" | nonZeroDigit { digit }) "." ("0" | nonZeroDigit { digit }) ["e" ["-"|"+"] ("0" | nonZeroDigit { digit })].

PRAGMAS

COMMENTS FROM "{" TO "}"
COMMENTS FROM "//" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

Pascal = 
(
	[ ImportsSection ]
	{ PreDeclaration }
	MainFunction
|
	Unit
)
.


ImportsSection
=
"uses"
identifier										(. factory.importUnit(t); .)
{
	","
	identifier									(. factory.importUnit(t); .)
}
";"
.



PreDeclaration
=
( 
	VariableDefinitions 
|
	ConstantDefinition
|
	Subroutine
)
.


ConstantDefinition
=
"const"
identifier										(. Token identifier = t; .)
"="
(
	floatLiteral								(. factory.createFloatConstant(identifier, t); .)	
|
	numericLiteral								(. factory.createIntegerConstant(identifier, t); .)	
|
	stringLiteral								(. factory.createStringOrCharConstant(identifier, t); .)	
|
												(. boolean l; .)
	LogicLiteral<out l>							(. factory.createBooleanConstant(identifier, l); .)	
)
";"
.


LogicLiteral<out boolean result>
=												(. result = false; .)
(
	"true"										(. result = true; .)
|
	"false"										(. result = false; .)
)
.



VariableDefinitions
=
"var"
VariableLineDefinition ";"
{
    VariableLineDefinition ";"
}
.


VariableLineDefinition
=                                               (. List<String> identifiers = new ArrayList<>(); .)
identifier                                      (. identifiers.add(t.val.toLowerCase()); .)
{
    ","
    identifier                                  (. identifiers.add(t.val.toLowerCase()); .)
}
":"
identifier                                      (. factory.finishVariableLineDefinition(identifiers, t); .) 
.


Subroutine
=
( Function | Procedure )
.


Procedure
=
"procedure"									
identifier										(. factory.startProcedure(t); .)
												(. Token name = t; .)
												(. List<VariableDeclaration> formalParameters = new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ] 	(. factory.addFormalParameters(formalParameters); .)
";" 											(. factory.checkUnitInterfaceMatchProcedure(name, formalParameters); .)
[ VariableDefinitions ]
Block<out StatementNode bodyNode>				(. factory.finishProcedure(bodyNode); .)
";"
.



Function
=												
"function"									
identifier										(. factory.startFunction(t); .)
												(. Token name = t; .)
												(. List<VariableDeclaration> formalParameters= new ArrayList<>(); .)
[ FormalParameterList<out formalParameters> ] 	(. factory.addFormalParameters(formalParameters); .)
":"
identifier										(. factory.setFunctionReturnValue(t); .)
												(. factory.checkUnitInterfaceMatchFunction(name, formalParameters,t.val.toLowerCase()); .)
";"
[ VariableDefinitions ]
Block<out StatementNode bodyNode>				(. factory.finishFunction(bodyNode); .)
";"
.


FormalParameterList<out List formalParameters>
=
(
	"("											(. List<VariableDeclaration> parameters = new ArrayList<>(); .)
												(. List<VariableDeclaration> parameter = new ArrayList<>(); .)
	FormalParameter<out parameter>				(. factory.appendFormalParameter(parameter, parameters); .)						
	{ 
		";" FormalParameter<out parameter> 		(. factory.appendFormalParameter(parameter, parameters); .)
	}
	")"
)												(. formalParameters = parameters; .)
.


FormalParameter<out List formalParameter>
=												(. formalParameter = new ArrayList<>(); .)
(
	ValueParameter<out formalParameter>
|
	VariableParameter<out formalParameter>
)
.


ValueParameter<out List formalParameter>
=												(. List<String> identifiers = new ArrayList<>(); .)
identifier										(. identifiers.add(t.val.toLowerCase()); .)
{
	","
	identifier									(. identifiers.add(t.val.toLowerCase()); .)
}
":"
identifier										(. formalParameter = factory.createFormalParametersList(identifiers, t.val.toLowerCase()); .)
.


VariableParameter<out List formalParameter>
=												(. List<String> identifiers = new ArrayList<>(); .)
identifier										(. identifiers.add(t.val.toLowerCase()); .)
{
	","
	identifier									(. identifiers.add(t.val.toLowerCase()); .)
}
":"
identifier										(. formalParameter = factory.createFormalParametersList(identifiers, t.val.toLowerCase()); .)
.



MainFunction 
= 							                    (. factory.startMainFunction(); .)
Block<out StatementNode blockNode>              (. mainNode = factory.finishMainFunction(blockNode); .)
"."
.


Block<out StatementNode blockNode>
=                                               
    "begin"                                     (. List<StatementNode> body = new ArrayList<>(); .)  
    [ 
        StatementSequence<body>
    ]
    "end"                                       (. blockNode = factory.finishBlock(body); .)
.


StatementSequence<List body>
=
Statement<out StatementNode statement>          (. body.add(statement); .)
{
    ";"
    Statement<out statement>                    (. body.add(statement); .)
}                                       
.


Statement<out StatementNode statement>
=                                               (. statement = null; .)
(
                                                (. statement = factory.createEmptyStatement(); .)
|
    Expression<out statement> 
|
    IfStatement<out statement>
|
	ForLoop<out statement>
|
	WhileLoop<out statement>
|
	RepeatLoop<out statement> 
|
	CaseStatement<out statement>
|
	"break"										(. if(loopDepth == 0) .)
												(. 		SemErr("Break statement outside of a loop."); .)
												(. statement = factory.createBreak(); .)
|
    Block<out statement>
)
.


CaseStatement<out StatementNode statement>
=
"case"
Expression<out ExpressionNode caseIndex>
"of"											(. factory.startCaseList();	.)
CaseList 										
"end"											(. statement = factory.finishCaseStatement(caseIndex); .)
.

CaseList
=
Expression<out ExpressionNode caseConstant>
":"
Statement<out StatementNode caseStatement>		(. factory.addCaseOption(caseConstant, caseStatement); .)
{
	IF(!caseEnds())
	";"
	Expression<out caseConstant>
	":"
	Statement<out caseStatement>				(. factory.addCaseOption(caseConstant, caseStatement); .)
}
[ ";" ]
.



ForLoop<out StatementNode statement>
=												(. loopDepth++; .)
"for"											(. boolean ascending = true; .)
identifier										(. Token variableToken = t; .)
":="
Expression<out ExpressionNode startValue>	
(
	"to"										(. ascending = true; .)
	|
	"downto"									(. ascending = false; .)
)
Expression<out ExpressionNode finalValue>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createForLoop(ascending, variableToken, startValue, finalValue, loopBody); .)
												(. loopDepth--; .)
.	


RepeatLoop<out StatementNode statement>
=												(. loopDepth++; .)
"repeat"										(. List<StatementNode> bodyNodes = new ArrayList<>(); .)
StatementSequence<bodyNodes>					
"until"
Expression<out ExpressionNode condition>		(. statement = factory.createRepeatLoop(condition, factory.finishBlock(bodyNodes)); .)
												(. loopDepth--; .)
.


WhileLoop<out StatementNode statement>
=												(. loopDepth++; .)
"while"
Expression<out ExpressionNode condition>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createWhileLoop(condition, loopBody); .)
												(. loopDepth--; .)
.


IfStatement<out StatementNode statement>
=
"if"                                            
    Expression<out ExpressionNode condition>

"then"                                          
    Statement<out StatementNode thenStatement>
                                                (. StatementNode elseStatement = null; .)
[
"else"                                          
    Statement<out elseStatement>
]                                               (. statement = factory.createIfStatement(condition, thenStatement, elseStatement); .)
.


Expression<out ExpressionNode expression>
=
LogicTerm<out expression>
{
    "or"                                        (. Token op = t; .)
    LogicTerm<out ExpressionNode right>         (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicTerm<out ExpressionNode expression>
=
LogicFactor<out expression>
{
    "and"                                       (. Token op = t; .)
    LogicFactor<out ExpressionNode right>       (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicFactor<out ExpressionNode expression>
=
Arithmetic<out expression>
[
    (">" | ">=" | "<" | "<=" | "=" | "<>")      (. Token op = t; .)
    Arithmetic<out ExpressionNode right>        (. expression = factory.createBinary(op, expression, right); .)
]
.


Arithmetic<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinary(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
SignedFactor<out expression>
{
    ( "*" | "/" | "div" | "mod")                (. Token op = t; .)
    SignedFactor<out ExpressionNode right>      (. expression = factory.createBinary(op, expression, right); .)
}
.


SignedFactor<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    ( "+" | "-" )                               (. Token unOp = t; .)
    SignedFactor<out expression>                (.  expression = factory.createUnary(unOp, expression); .)
|
    Factor<out expression>                                        
)
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	identifier
    (
	    MemberExpression<out expression, t>
    |
                                                (. expression = factory.readVariable(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Undefined variable " + t.val + "."); .)
    )
|
    "("
    Expression<out expression>                  
    ")"
|
	stringLiteral					            (. expression = factory.createCharOrStringLiteral(t); .)
|
	floatLiteral								(. expression = factory.createFloatLiteral(t); .)
|
    numericLiteral                              (. expression = factory.createNumericLiteral(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Constant out of range!"); .)
|
												(. boolean val; .)
    LogicLiteral<out val>						(. expression = factory.createLogicLiteral(val); .)
)
.



MemberExpression<out ExpressionNode expression, Token identifierName>
=							                    (. expression = null; .)
(                                               
	"("						                    (. ExpressionNode functionNode = factory.createFunctionNode(identifierName); .)
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
                                                (. ExpressionNode parameter; .)
		[
			Expression<out parameter>           (. parameters.add(parameter); .)
			{
				","
				Expression<out parameter>       (. parameters.add(parameter); .)
			}
		]
	")"                                         (. expression = factory.createCall(functionNode, parameters); .)
|
    ":="
    Expression<out ExpressionNode value>        (. if(identifierName == null) { .) 
                                                (.      SemErr("Invalid assignment target!"); .)
                                                (. } else { .)
                                                (.      expression = factory.createAssignment(identifierName, value); .)
                                                (.      if(expression == null) .)
                                                (.          SemErr("Undefined variable " + identifierName.val.toLowerCase() + "."); .)
                                                (. } .)
)
.



Unit
=
"unit"
identifier										(. factory.startUnit(t); .)
";"
"interface"
InterfaceSection
"implementation"
ImplementationSection
"end"										(. factory.endUnit(); .)
"."
.


InterfaceSection
=
{
	(
		ProcedureHeading
	|
		FunctionHeading
	|
		VariableDefinitions
	)
}
.



ProcedureHeading
=
"procedure"
identifier										(. Token name = t; .)
												(. List<VariableDeclaration> formalParameters = new ArrayList<>(); .)
[ IFormalParameterList<out formalParameters> ] 		
												(. factory.addProcedureInterface(name, formalParameters); .)
";"
.



FunctionHeading
=
"function"
identifier										(. Token name = t; .)
												(. List<VariableDeclaration> formalParameters = new ArrayList<>(); .)
[ IFormalParameterList<out formalParameters> ] 
":"
identifier										(. String returnValue = t.val; .)
												(. factory.addFunctionInterface(name, formalParameters, returnValue); .)
";"
.


IFormalParameterList<out List formalParameters>
=												(. formalParameters = new ArrayList<VariableDeclaration>(); .)
"("												(. List<VariableDeclaration> formalParameter = new ArrayList<>(); .)
	IFormalParameter<out formalParameter>		(. factory.appendFormalParameter(formalParameter, formalParameters); .)
	{
		";"
		IFormalParameter<out formalParameter>	(. factory.appendFormalParameter(formalParameter, formalParameters); .)
	}											
")"
.



IFormalParameter<out List formalParameter>
=												(. formalParameter = new ArrayList<VariableDeclaration>(); .)
(
	IValueParameter<out formalParameter>
|
	IVariableParameter<out formalParameter>
)
.



IValueParameter<out List formalParameter>
=												(. List<String> identifiers = new ArrayList<>(); .)
identifier										(. identifiers.add(t.val); .)
{
	","
	identifier									(. identifiers.add(t.val); .)
}
":"
identifier										(. String typeName = t.val; .)
												(. formalParameter = factory.createFormalParametersList(identifiers, typeName); .)
.



IVariableParameter<out List formalParameter>
=												(. List<String> identifiers = new ArrayList<>(); .)
"var"
identifier										(. identifiers.add(t.val); .)			
{
	","
	identifier									(. identifiers.add(t.val); .)
}
":"
identifier										(. String typeName = t.val; .)
												(. formalParameter = factory.createFormalParametersList(identifiers, typeName); .)
.


ImplementationSection
=
{
	(
		Subroutine
	|
		VariableDefinitions
	)
}
.

END Pascal.
