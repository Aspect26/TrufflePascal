COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit} .
stringLiteral = "'" { stringChar } "'".
numericLiteral = "0" | nonZeroDigit { digit }.
variableType = "long".

PRAGMAS

COMMENTS FROM "{" TO "}"
COMMENTS FROM "//" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

Pascal = 
[ VariableDefinitions ]
MainFunction
.


VariableDefinitions
=
"var"
VariableLineDefinition
{
    VariableLineDefinition
}
.


VariableLineDefinition
=                                               (. factory.startVariableLineDefinition(); .)
identifier                                      (. factory.addNewUnknownVariable(t); .)
{
    ","
    identifier                                  (. factory.addNewUnknownVariable(t); .)
}
":"
variableType  ";"                               (. factory.finishVariableLineDefinition(t); .) 
.



MainFunction 
= 							                    (. factory.startMainFunction(); .)
MainBlock<out StatementNode blockNode>          (. mainNode = factory.finishMainFunction(blockNode); .)
.



MainBlock<out StatementNode blockNode>
= 							                    (. factory.startMainBlock(); .)
"BEGIN" 						                (. List<StatementNode> body = new ArrayList<>(); .)
{ 
	Statement<out StatementNode statement>  	(. body.add(statement); .)
} 
"END."							                (. blockNode = factory.finishMainBlock(body); .)
.

Statement<out StatementNode statement>
=
(
    Expression<out statement> ";"
)
.


Expression<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinary(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
Factor<out expression>
{
    ( "*" | "div" )                             (. Token op = t; .)
    Factor<out ExpressionNode right>            (. expression = factory.createBinary(op, expression, right); .)
}
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	identifier
    (
	    MemberExpression<out expression, null, t>
    |
                                                (. expression = factory.readVariable(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Undefined variable!"); .)
    )
|
	stringLiteral					            (. expression = factory.createStringLiteral(t); .)
|
    numericLiteral                              (. expression = factory.createNumericLiteral(t); .)
)
.



MemberExpression<out ExpressionNode expression, ExpressionNode r, Token assignmentName>
=							                    (. expression = null; .)
(                                               (. ExpressionNode receiver = r; .)
	"("						                    (. if(receiver == null); 
                                                      receiver = factory.createFunctionNode(assignmentName); .)
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
                                                (. ExpressionNode parameter; .)
		[
			Expression<out parameter>           (. parameters.add(parameter); .)
			{
				","
				Expression<out parameter>       (. parameters.add(parameter); .)
			}
		]
	")"                                         (. expression = factory.createCall(receiver, parameters); .)
|
    ":="
    Expression<out ExpressionNode value>        (. if(assignmentName == null) { .) 
                                                (.      SemErr("Invalid assignment target!"); .)
                                                (. } else { .)
                                                (.      expression = factory.createAssignment(assignmentName, value); .)
                                                (.      if(expression == null) .)
                                                (.          SemErr("Undefined variable!"); .)
                                                (. } .)
)
.


END Pascal.
