COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit}.
stringLiteral = "'" { stringChar } "'".
numericLiteral = "0" | nonZeroDigit { digit }.

PRAGMAS

COMMENTS FROM "{" TO "}"
COMMENTS FROM "//" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

Pascal = 
[ VariableDefinitions ]
MainFunction
.


VariableDefinitions
=
"var"
VariableLineDefinition
{
    VariableLineDefinition
}
.


VariableLineDefinition
=                                               (. factory.startVariableLineDefinition(); .)
identifier                                      (. factory.addNewUnknownVariable(t); .)
{
    ","
    identifier                                  (. factory.addNewUnknownVariable(t); .)
}
":"
identifier                                      (. factory.finishVariableLineDefinition(t); .) 
    ";" 
.



MainFunction 
= 							                    (. factory.startMainFunction(); .)
Block<out StatementNode blockNode>              (. mainNode = factory.finishMainFunction(blockNode); .)
"."
.


Block<out StatementNode blockNode>
=                                               
    "begin"                                     (. List<StatementNode> body = new ArrayList<>(); .)  
    [ 
        StatementSequence<body>
    ]
    "end"                                       (. blockNode = factory.finishBlock(body); .)
.


StatementSequence<List body>
=
Statement<out StatementNode statement>          (. body.add(statement); .)
{
    ";"
    Statement<out statement>                    (. body.add(statement); .)
}                                       
.


Statement<out StatementNode statement>
=                                               (. statement = null; .)
(
                                                (. statement = factory.createEmptyStatement(); .)
|
    Expression<out statement> 
|
    IfStatement<out statement>
|
	ForLoop<out statement>
|
	WhileLoop<out statement>
|
	RepeatLoop<out statement> 
|
	"break"										(. statement = factory.createBreak(); .)
|
    Block<out statement>
)
.


ForLoop<out StatementNode statement>
=
"for"											(. boolean ascending = true; .)
identifier										(. Token variableToken = t; .)
":="
Expression<out ExpressionNode startValue>	
(
	"to"										(. ascending = true; .)
	|
	"downto"									(. ascending = false; .)
)
Expression<out ExpressionNode finalValue>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createForLoop(ascending, variableToken, startValue, finalValue, loopBody); .)
.	


RepeatLoop<out StatementNode statement>
=
"repeat"										(. List<StatementNode> bodyNodes = new ArrayList<>(); .)
StatementSequence<bodyNodes>					
"until"
Expression<out ExpressionNode condition>		(. statement = factory.createRepeatLoop(condition, factory.finishBlock(bodyNodes)); .)
.


WhileLoop<out StatementNode statement>
=
"while"
Expression<out ExpressionNode condition>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createWhileLoop(condition, loopBody); .)
.


IfStatement<out StatementNode statement>
=
"if"                                            
    Expression<out ExpressionNode condition>

"then"                                          
    Statement<out StatementNode thenStatement>
                                                (. StatementNode elseStatement = null; .)
[
"else"                                          
    Statement<out elseStatement>
]                                               (. statement = factory.createIfStatement(condition, thenStatement, elseStatement); .)
.


Expression<out ExpressionNode expression>
=
LogicTerm<out expression>
{
    "or"                                        (. Token op = t; .)
    LogicTerm<out ExpressionNode right>         (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicTerm<out ExpressionNode expression>
=
LogicFactor<out expression>
{
    "and"                                       (. Token op = t; .)
    LogicFactor<out ExpressionNode right>       (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicFactor<out ExpressionNode expression>
=
Arithmetic<out expression>
[
    (">" | ">=" | "<" | "<=" | "=" | "<>")      (. Token op = t; .)
    Arithmetic<out ExpressionNode right>        (. expression = factory.createBinary(op, expression, right); .)
]
.


Arithmetic<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinary(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
SignedFactor<out expression>
{
    ( "*" | "div" | "mod")                      (. Token op = t; .)
    SignedFactor<out ExpressionNode right>      (. expression = factory.createBinary(op, expression, right); .)
}
.


SignedFactor<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    ( "+" | "-" )                               (. Token unOp = t; .)
    SignedFactor<out expression>                (.  expression = factory.createUnary(unOp, expression); .)
|
    Factor<out expression>                                        
)
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	identifier
    (
	    MemberExpression<out expression, null, t>
    |
                                                (. expression = factory.readVariable(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Undefined variable!"); .)
    )
|
    "("
    Expression<out expression>                  
    ")"
|
	stringLiteral					            (. expression = factory.createCharLiteral(t); .)
|
    numericLiteral                              (. expression = factory.createNumericLiteral(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Constant out of range!"); .)
|
    LogicLiteral<out expression>
)
.


LogicLiteral<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    "true"                                      (. expression = factory.createLogicLiteral(true); .)
|
    "false"                                     (. expression = factory.createLogicLiteral(false); .)
)
.



MemberExpression<out ExpressionNode expression, ExpressionNode r, Token assignmentName>
=							                    (. expression = null; .)
(                                               (. ExpressionNode receiver = r; .)
	"("						                    (. if(receiver == null); 
                                                      receiver = factory.createFunctionNode(assignmentName); .)
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
                                                (. ExpressionNode parameter; .)
		[
			Expression<out parameter>           (. parameters.add(parameter); .)
			{
				","
				Expression<out parameter>       (. parameters.add(parameter); .)
			}
		]
	")"                                         (. expression = factory.createCall(receiver, parameters); .)
|
    ":="
    Expression<out ExpressionNode value>        (. if(assignmentName == null) { .) 
                                                (.      SemErr("Invalid assignment target!"); .)
                                                (. } else { .)
                                                (.      expression = factory.createAssignment(assignmentName, value); .)
                                                (.      if(expression == null) .)
                                                (.          SemErr("Undefined variable!"); .)
                                                (. } .)
)
.


END Pascal.
