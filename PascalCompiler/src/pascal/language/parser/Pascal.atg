COMPILER Pascal

IGNORECASE

CHARACTERS

letter = 'A'..'Z' + 'a'..'z'.
nonZeroDigit = "123456789".
digit = "0123456789".

cr = '\r'.
lf = '\n'.
tab = '\t'.

stringChar = ANY - "'" - cr - lf.

TOKENS

identifier = letter {letter | digit}.
stringLiteral = "'" { stringChar } "'".
numericLiteral = "0" | nonZeroDigit { digit }.

PRAGMAS

COMMENTS FROM "{" TO "}"
COMMENTS FROM "//" TO lf
IGNORE cr + lf + tab

PRODUCTIONS

Pascal = 
(
	[ ImportsSection ]
	[ VariableDefinitions ]
	{ Subroutine }
	MainFunction
|
	Unit
)
.


ImportsSection
=
"uses"
identifier										(. factory.importUnit(t.val); .)
{
	","
	identifier									(. factory.importUnit(t.val); .)
}
";"
.



VariableDefinitions
=
"var"
VariableLineDefinition ";"
{
    VariableLineDefinition ";"
}
.


VariableLineDefinition
=                                               (. factory.startVariableLineDefinition(); .)
identifier                                      (. factory.addNewUnknownVariable(t); .)
{
    ","
    identifier                                  (. factory.addNewUnknownVariable(t); .)
}
":"
identifier                                      (. factory.finishVariableLineDefinition(t); .) 
.


Subroutine
=
( Function | Procedure )
.


Procedure
=
"procedure"									
identifier										(. factory.startProcedure(t); .)
[ FormalParameterList ] ";" 
[ VariableDefinitions ]
Block<out StatementNode bodyNode>				(. factory.finishProcedure(bodyNode); .)
";"
.



Function
=												
"function"									
identifier										(. factory.startFunction(t); .)
[ FormalParameterList ] 
":"
identifier										(. factory.setFunctionReturnValue(t); .)
";"												
[ VariableDefinitions ]
Block<out StatementNode bodyNode>				(. factory.finishFunction(bodyNode); .)
";"
.


FormalParameterList
=
(
	"("
	FormalParameter
	{ ";" FormalParameter }
	")"
)
.


FormalParameter
=
(
	ValueParameter
|
	VariableParameter
)
.


ValueParameter
=												(. List<String> identifiers = new ArrayList<>(); .)
identifier										(. identifiers.add(t.val); .)
{
	","
	identifier									(. identifiers.add(t.val); .)
}
":"
identifier										(. factory.addFormalParameters(identifiers, t.val); .)
.


VariableParameter
=													
identifier
{
	","
	identifier
}
":"
identifier
.



MainFunction 
= 							                    (. factory.startMainFunction(); .)
Block<out StatementNode blockNode>              (. mainNode = factory.finishMainFunction(blockNode); .)
"."
.


Block<out StatementNode blockNode>
=                                               
    "begin"                                     (. List<StatementNode> body = new ArrayList<>(); .)  
    [ 
        StatementSequence<body>
    ]
    "end"                                       (. blockNode = factory.finishBlock(body); .)
.


StatementSequence<List body>
=
Statement<out StatementNode statement>          (. body.add(statement); .)
{
    ";"
    Statement<out statement>                    (. body.add(statement); .)
}                                       
.


Statement<out StatementNode statement>
=                                               (. statement = null; .)
(
                                                (. statement = factory.createEmptyStatement(); .)
|
    Expression<out statement> 
|
    IfStatement<out statement>
|
	ForLoop<out statement>
|
	WhileLoop<out statement>
|
	RepeatLoop<out statement> 
|
	CaseStatement<out statement>
|
	"break"										(. statement = factory.createBreak(); .)
|
    Block<out statement>
)
.


CaseStatement<out StatementNode statement>
=
"case"
Expression<out ExpressionNode caseIndex>
"of"											(. factory.startCaseList();	.)
CaseList 										
"end"											(. statement = factory.finishCaseStatement(caseIndex); .)
.

CaseList
=
Expression<out ExpressionNode caseConstant>
":"
Statement<out StatementNode caseStatement>		(. factory.addCaseOption(caseConstant, caseStatement); .)
{
	";"
	Expression<out caseConstant>
	":"
	Statement<out caseStatement>	(. factory.addCaseOption(caseConstant, caseStatement); .)
}
.



ForLoop<out StatementNode statement>
=
"for"											(. boolean ascending = true; .)
identifier										(. Token variableToken = t; .)
":="
Expression<out ExpressionNode startValue>	
(
	"to"										(. ascending = true; .)
	|
	"downto"									(. ascending = false; .)
)
Expression<out ExpressionNode finalValue>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createForLoop(ascending, variableToken, startValue, finalValue, loopBody); .)
.	


RepeatLoop<out StatementNode statement>
=
"repeat"										(. List<StatementNode> bodyNodes = new ArrayList<>(); .)
StatementSequence<bodyNodes>					
"until"
Expression<out ExpressionNode condition>		(. statement = factory.createRepeatLoop(condition, factory.finishBlock(bodyNodes)); .)
.


WhileLoop<out StatementNode statement>
=
"while"
Expression<out ExpressionNode condition>
"do"
Statement<out StatementNode loopBody>			(. statement = factory.createWhileLoop(condition, loopBody); .)
.


IfStatement<out StatementNode statement>
=
"if"                                            
    Expression<out ExpressionNode condition>

"then"                                          
    Statement<out StatementNode thenStatement>
                                                (. StatementNode elseStatement = null; .)
[
"else"                                          
    Statement<out elseStatement>
]                                               (. statement = factory.createIfStatement(condition, thenStatement, elseStatement); .)
.


Expression<out ExpressionNode expression>
=
LogicTerm<out expression>
{
    "or"                                        (. Token op = t; .)
    LogicTerm<out ExpressionNode right>         (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicTerm<out ExpressionNode expression>
=
LogicFactor<out expression>
{
    "and"                                       (. Token op = t; .)
    LogicFactor<out ExpressionNode right>       (. expression = factory.createBinary(op, expression, right); .)
}
.


LogicFactor<out ExpressionNode expression>
=
Arithmetic<out expression>
[
    (">" | ">=" | "<" | "<=" | "=" | "<>")      (. Token op = t; .)
    Arithmetic<out ExpressionNode right>        (. expression = factory.createBinary(op, expression, right); .)
]
.


Arithmetic<out ExpressionNode expression>
=
Term<out expression>
{
    ( "+" | "-" )                               (. Token op = t; .)
    Term<out ExpressionNode right>              (. expression = factory.createBinary(op, expression, right); .)
}
.


Term<out ExpressionNode expression>
=
SignedFactor<out expression>
{
    ( "*" | "div" | "mod")                      (. Token op = t; .)
    SignedFactor<out ExpressionNode right>      (. expression = factory.createBinary(op, expression, right); .)
}
.


SignedFactor<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    ( "+" | "-" )                               (. Token unOp = t; .)
    SignedFactor<out expression>                (.  expression = factory.createUnary(unOp, expression); .)
|
    Factor<out expression>                                        
)
.



Factor<out ExpressionNode expression>
=							                    (. expression = null; .)
(
	identifier
    (
	    MemberExpression<out expression, t>
    |
                                                (. expression = factory.readVariable(t); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Undefined variable!"); .)
    )
|
    "("
    Expression<out expression>                  
    ")"
|
	stringLiteral					            (. expression = factory.createCharLiteral(t); .)
|
    numericLiteral                              (. Token integerPartToken; .)
												(. Token fractionalPartToken = null; .)
												(. Token exponentOpToken = null; .)
												(. Token exponentToken = null; .)
												(. integerPartToken = t; .)
    (
    											(. expression = factory.createNumericLiteral(integerPartToken); .)
                                                (. if(expression == null) .)
                                                (.      SemErr("Constant out of range!"); .)
    |
		(
			"."
			numericLiteral						(. fractionalPartToken = t; .)
			[
				"e"
				[ ( "+" | "-" ) ]				(. exponentOpToken = t; .)
				numericLiteral					(. exponentToken = t; .)
			]
		|
			"e"
			[ ( "+" | "-" ) ]					(. exponentOpToken = t; .)
			numericLiteral						(. exponentToken = t; .)
		)										(. expression = factory.createRealLiteral(integerPartToken, .)
												(. fractionalPartToken, exponentOpToken, exponentToken); .)    	
    )
|
    LogicLiteral<out expression>
)
.


LogicLiteral<out ExpressionNode expression>
=                                               (. expression = null; .)
(
    "true"                                      (. expression = factory.createLogicLiteral(true); .)
|
    "false"                                     (. expression = factory.createLogicLiteral(false); .)
)
.



MemberExpression<out ExpressionNode expression, Token identifierName>
=							                    (. expression = null; .)
(                                               
	"("						                    (. ExpressionNode functionNode = factory.createFunctionNode(identifierName); .)
                                                (. List<ExpressionNode> parameters = new ArrayList<>(); .)
                                                (. ExpressionNode parameter; .)
		[
			Expression<out parameter>           (. parameters.add(parameter); .)
			{
				","
				Expression<out parameter>       (. parameters.add(parameter); .)
			}
		]
	")"                                         (. expression = factory.createCall(functionNode, parameters); .)
|
    ":="
    Expression<out ExpressionNode value>        (. if(identifierName == null) { .) 
                                                (.      SemErr("Invalid assignment target!"); .)
                                                (. } else { .)
                                                (.      expression = factory.createAssignment(identifierName, value); .)
                                                (.      if(expression == null) .)
                                                (.          SemErr("Undefined variable!"); .)
                                                (. } .)
)
.



Unit
=
"unit"
identifier										(. factory.startUnit(t); .)
"interface"
InterfaceSection
"implementation"
ImplementationSection
"end."
.


InterfaceSection
=
{
	(
		ProcedureHeading
	|
		FunctionHeading
	)
}
.



ProcedureHeading
=
"procedure"
identifier										(. String name = t.val; .)
												(. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ IFormalParameterList<out formalParameters> ] 		
												(. factory.addProcedureInterface(name, formalParameters); .)
.



FunctionHeading
=
"function"
identifier										(. String name = t.val; .)
												(. List<FormalParameter> formalParameters = new ArrayList<>(); .)
[ IFormalParameterList<out formalParameters> ] 
":"
identifier										(. String returnValue = t.val; .)
												(. factory.addFunctionInterface(name, formalParameters, returnValue); .)
.


IFormalParameterList<out List formalParameters>
=
"FPRS"											(. formalParameters = new ArrayList<>(); .)
.



ImplementationSection
=
"IMPLEMENTATION"
.

END Pascal.
